
# Архитектурный документ Black Friday
# Проектирование схем коллекций для шардирования данных (Задание 7)
## Коллекция products — Товары
### Shema: Product
```json

{
  "_id": "unique_product_id",
  "name": "Смартфон X",
  "category": "Электроника",
  "price": 15000,
  "stock_by_zone": {
    "moscow": 50,
    "ekaterinburg": 30
  },
  "attributes": {
    "color": "черный",
    "size": "medium"
  }
}
```
### Основные операции:
- Частые обновления остатков (на основе геозоны).
- Поиск по категории и цене.
- Получение полного описания товара.
### Шард-ключ: ```{ category: 1, price: 1 }```
Горизонтальное шардирование по категориям и цене
- Запросы часто фильтруют товары по категории и ценовому диапазону .
Э- то равномерно распределит данные по шардам, избегая горячих точек.
- Если бы мы использовали _id, это привело бы к неравномерному распределению при сканировании.
- Цена позволяет дополнительно разделить данные внутри категории.

### Индекс
```
products { category: 1, price: 1 }, { _id: 1 }
```

## Коллекция orders — Заказы:
### Shema: Order
```json
{
  "_id": "order_1",
  "user_id": "user_69",
  "created_at": ISODate("..."),
  "items": [
    { "product_id": "p1", "price": 15000 },
    { "product_id": "p2", "price": 800 }
  ],
  "status": "processing",
  "total_amount": 15800,
  "zone": "moscow"
}
```
### Основные операции:
- Быстрое создание заказов с одновременным списанием остатков.
- Поиск истории заказов конкретного пользователя.
- Отображение статуса заказа

### Шард-ключ: ```{ user_id: 1 }```
Шардирование по id пользователя
- Большинство запросов связаны с конкретным пользователем (история заказов).
- Группировка заказов одного пользователя в один шард упрощает чтение и оптимизирует производительность.

### Индекс
```
orders { user_id: 1, created_at: -1 }, { status: 1 }
```
## Коллекция carts — Корзины
### Shema: Сart
```json
{
  "_id": "cart_123",
  "user_id": "user_69",
  "session_id": "sess_789",
  "items": [
    { "product_id": "p1", "quantity": 2 }
  ],
  "status": "active", //active | ordered | abandoned
  "created_at": ISODate("..."),
  "updated_at": ISODate("..."),
  "expires_at": ISODate("...")
}
```
### Основные операции:
- Создание корзин (гостевых и пользовательских).
- Получение активной корзины.
- Обновление/удаление товаров.
- Слияние гостевой корзины в пользовательскую, если пользователь залогинится:
    прочитать гостевую { session_id, status:"active" };
    добавить её items в корзину { user_id, status:"active" };
    отметить гостевую как abandoned.
- Отметка корзины как заказанной.

### Шард-ключ: ```{ user_id: 1 }``` или ```{ session_id: 1 }```
 Шардирование по пользователю или сессии
- Для пользовательских корзин : шардировать по user_id — логично, так как большинство операций идет по пользователю.
- Для гостевых корзин : шардировать по session_id — аналогично, поскольку они ассоциированы с сессией.
- При слиянии можно временно использовать оба ключа.

### Индекс
```
carts { user_id: 1, status: 1 }, { session_id: 1, status: 1 }, { expires_at: 1 }
``` 
## Итого о шардировании коллекциях
|Коллекция|Шард-ключ|Тип|Комментарий|
|--|--|--|--|
|products|{ category: 1, price: 1 }|Горизонтальное шардирование|Подходит для фильтрации по категории и цене; равномерное распределение данных|
|orders|{ user_id: 1 }|Шардирование по пользователю|Позволяет быстро получать историю заказов конкретного пользователя|
|carts|{ user_id: 1 } <br>или<br> { session_id: 1 }|Шардирование по пользователю или сессии|Эффективно для работы с активными корзинами и их обновлениями| 

## Дополнительно: Масштабирование
Если потребуется масштабировать систему дальше, можно рассмотреть:
- Zone-based sharding для orders и products по геозонам.
- Time-based partitioning для старых заказов.

# Выявление и устранение «горячих» шардов (Задание 8)

## Контекст проблемы
В текущей системе произошёл дисбаланс нагрузки между шардами из-за концентрации 70% запросов на категории "Электроника". Это привело к перегрузке одного из шардов и ухудшению общей производительности. Необходимо разработать механизм проактивного мониторинга и автоматического балансирования нагрузки.

## Цель
Разработать стратегию:
   * Для выявления горячих шардов.
   * Для устранения дисбаланса.
   * Для предотвращения подобных ситуаций в будущем с помощью мониторинга и автоматизации.

## Диагностика
Для эффективного контроля состояния шардов необходимо отслеживать следующие ключевые метрики:

|Описание|Команда|
|--|--|
|Интенсивность операций по типам| db.serverStatus().opcounters|
|Текущее количество активных операций|db.serverStatus().globalLock.currentQueue|
|Количество активных клиентских соединений| db.serverStatus().globalLock.activeClients|
|Объём входящего/исходящего сетевого трафика|db.serverStatus().network|
|Статистика по коллекциям в каждом шарде|db.collection.stats()|
|Распределение чанков по шардам|sh.status()|
|Задержка выполнения запросов|db.collection.aggregate([{$indexStats: {}}])|Число активных соединений на шард|db.curr|

## Способы устранение дисбаланса MongoDB

|Цель|Рекомендация||
|--|--|--|
|Автоматизация| Включить балансировщик |
|Холодные данные | Использовать hash-ключ |
|Горячие данные | Использовать составной ключ, чтобы дробить коллекции  |
|Масштабирование | Добавить новый шард |

## Способ 1 - Включить автоматический балансировщик (Balancer)
### MongoDB имеет встроенный балансировщик чанков между шардами
```
sh.getBalancerState() //проверить включен ли балансировщик
```
Включи балансировку, если выключено
```
sh.startBalancer()
```

### Можно мастроить время работы Balancer, для регулярной ребалансировки в определенное время.
По умолчанию работает круглосуточно, но можно задать временной интервал

Например, ограничить работу балансировщика ночным временем:
```
use config
db.settings.updateOne(
  { _id: "balancer" },
  {
    $set: {
      activeWindow : { start : "02:00", stop : "06:00" }
    }
  },
  { upsert: true }
)
```

## Способ 2 - Изменение ключа
### 2.1. Хэш-ключ
Варинт по умолчанию.

Но может случиться так, что все популярные позиции СЛУЧАЙНО придутся на один шард.

```
sh.shardCollection("store.products", { productId: "hashed" })
```
### 2.2. Составной ключ

Можно использовать составной ключ, чтобы "дробить" попурярные разделы.
Например, вместо ключа ```{ categoryId }``` использовать ```{ categoryId, brandId }```


## Способ 3 - Ручная балансировка шардов
Если нужно немедленно разгрузить шард — можно вручную переместить чанки
```
use admin
db.runCommand({
  moveChunk: "your_db.products",
  find: { categoryId: "electronics" },  // какой документ/диапазон перемещаем
  to: "target_shard_name"               // куда перемещаем
})
```

## Способ 4 - Добавление новых шардов
При росте общей регулярной нагрузки нужно добавить новые шарды:

```
sh.addShard("new-shard-hostname:27018") // Создать новый шард
sh.status() // сразу проверь
```


# Настройка чтения с реплик и консистентность (Задание 9)

|Коллекция|Операция|Тип чтения|Допустимая задержка|Комментарий|
|-|-|-|-|-| 
|products|Получить каталог продуктов|secondary|~ >60 сек|Данные не меняются часто, если, например, добавился новый продукт, пользователи врядли смогут его найти среди уже более популярных товаров|
|products|Получить информацию о продукте|secondary|~ >60 сек|Описание товара также не меняется часто и не ведёт к большим рискам|
|products|Проверить наличие товаров|primary|0|Если проверяется наличие перед оформлением заказа, необходимо убедиться, что данные актуальны. Иначе — риск продать товар, которого уже нет|
|orders|Аналитика по заказам|secondary|~ >60 сек|Это аналитика или история, где свежесть данных менее критична|
|carts|Просмотр содержимого корзины|primary|0|Критически важно для пользователя, он должен точно это знать, перед оформлением заказа|
|carts|Подсчёт суммы|primary|0|Недопустима даже возможность "обмануть" пользователя|

# Миграция на Cassandra (Задание 10)
## 10.1 - Обоснование применения Cassandra для указанных сущностей
Cassandra — это лидерless распределенная NoSQL БД, которая идеально подходит для сценариев:

- Высокой скорости записи : например, обработка множества событий от пользователей.
- Равномерного распределения данных : благодаря consistent hashing и token-aware роутингу.
- Горизонтального масштабирования : при добавлении новых узлов Cassandra не перераспределяет все данные сразу, а постепенно балансирует нагрузку.
- Отказоустойчивости : отсутствие single point of failure.

### Products
Особого прироста производительности перенос products в Cassandra не даст, т.к. это данные меняются редко. А самые популярные и запросы попадут в кэш.
- Единственный плюс -> высокая доступность и геораспределение

### Orders
Cassandra подходит благодаря отказоустойчивости, распределению нагрузки и возможности горизонтального масштабирования

- Это основной источник дохода.
- Требуется гарантированная запись без потерь.
- Частые изменения статусов
- Важна история заказов для пользователей и аналитики

```sql
CREATE TABLE orders (
    user_id UUID,
    order_id UUID,
    created_at TIMESTAMP,
    status TEXT,
    total_amount DECIMAL,
    zone TEXT,
    items LIST<FROZEN<ITEM>>,
    PRIMARY KEY ((user_id), created_at)
) WITH CLUSTERING ORDER BY (created_at DESC);
```
Обоснование структуры:
- user_id как partition key — все заказы одного пользователя попадают в одну партицию.
- created_at как clustering key — позволяет эффективно фильтровать по времени.
- items хранятся в виде списка вложенных объектов (FROZEN), чтобы избежать сложных JOIN’ов

### Carts
Cassandra подходит
- Хранят временные данные о товарах перед оформлением заказа.
- Частое изменение содержимого корзины.
- Важно сохранить корзину при переходе от гостя к авторизованному пользователю

```sql
CREATE TYPE item_type (
    product_id UUID,
    quantity INT,
    price DECIMAL
);

CREATE TABLE carts_by_user (
    user_id UUID PRIMARY KEY,
    cart_id UUID,
    expires_at TIMESTAMP,
    items LIST<FROZEN<item_type>>,
    updated_at TIMESTAMP
);

CREATE TABLE carts_by_session (
    session_id UUID PRIMARY KEY,
    cart_id UUID,
    expires_at TIMESTAMP,
    items LIST<FROZEN<item_type>>,
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);

CREATE TABLE user_sessions (
    session_id UUID PRIMARY KEY,
    user_id UUID,
    data TEXT,
    expires_at TIMESTAMP
) WITH default_time_to_live = 86400;
```
Хранение информации о сессии пользователя.
Обоснование структуры:
- Хранение одной активной корзины на пользователя.
Удобство обновления/чтения по user_id.
- После входа пользователя можно легко получить гостевую корзину и объединить с пользовательской
- Каждая сессия уникальна и хранится как отдельная запись, кластерный ключ не нужен.
- TTL автоматически удаляет истекшие сессии.
- Преимущества:
    - Быстрое получение сессии.
    - Автоматическая очистка старых записей.


## 10.2 Концептуальная модель
|Коллекция| Partition Key|Clustering Key|Цель|
|-|-|-|-|
|orders|user_id|created_at|История заказов|
|carts_by_user|user_id|—|Корзина пользователя
|carts_by_session|session_id|—|Гостевая корзина
|user_sessions|session_id|—|Сессии

## 10.3 Стратегии восстановления целостности

Общие рекомендации:
|Коллекция|Hinted Handoff|Read Repair|Anti-entropy repair| Комментарий|
|--|--|--|--|--|
|orders|да|да|да|Критичные данные.Требуют максимальной надежности|
|carts_by_user|да|нет|да|Важно сохранять данные, но допустимы небольшие ошибки|
|carts_by_session|да|нет|нет|Гостевые данные, менее критичны|
|user_sessions|да|нет|да|Сессии должны восстанавливаться при решардинге|